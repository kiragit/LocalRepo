<!DOCTYPE html>

<html>
<head>
  <title>indexes.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>indexes.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> BinarySearchTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'binary-search-tree'</span>).AVLTree
  , model = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./model'</span>)
  , _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>)
  , util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>)
  ;

<span class="hljs-comment">/**
 * Two indexed pointers are equal iif they point to the same place
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkValueEquality</span> <span class="hljs-params">(a, b)</span> </span>{
  <span class="hljs-keyword">return</span> a === b;
}

<span class="hljs-comment">/**
 * Type-aware projection
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">projectForUnique</span> <span class="hljs-params">(elt)</span> </span>{
  <span class="hljs-keyword">if</span> (elt === <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'$null'</span>; }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elt === <span class="hljs-string">'string'</span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'$string'</span> + elt; }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elt === <span class="hljs-string">'boolean'</span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'$boolean'</span> + elt; }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elt === <span class="hljs-string">'number'</span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'$number'</span> + elt; }
  <span class="hljs-keyword">if</span> (util.isArray(elt)) { <span class="hljs-keyword">return</span> <span class="hljs-string">'$date'</span> + elt.getTime(); }
  
  <span class="hljs-keyword">return</span> elt;   <span class="hljs-comment">// Arrays and objects, will check for pointer equality</span>
}


<span class="hljs-comment">/**
 * Create a new index
 * All methods on an index guarantee that either the whole operation was successful and the index changed
 * or the operation was unsuccessful and an error is thrown while the index is unchanged
 * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)
 * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)
 * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span> <span class="hljs-params">(options)</span> </span>{
  <span class="hljs-keyword">this</span>.fieldName = options.fieldName;
  <span class="hljs-keyword">this</span>.unique = options.unique || <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.sparse = options.sparse || <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">this</span>.treeOptions = { unique: <span class="hljs-keyword">this</span>.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };

  <span class="hljs-keyword">this</span>.reset();   <span class="hljs-comment">// No data in the beginning</span>
}


<span class="hljs-comment">/**
 * Reset an index
 * @param {Document or Array of documents} newData Optional, data to initialize the index with
 *                                                 If an error is thrown during insertion, the index is not modified
 */</span>
Index.prototype.reset = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newData)</span> </span>{
  <span class="hljs-keyword">this</span>.tree = <span class="hljs-keyword">new</span> BinarySearchTree(<span class="hljs-keyword">this</span>.treeOptions);

  <span class="hljs-keyword">if</span> (newData) { <span class="hljs-keyword">this</span>.insert(newData); }
};


<span class="hljs-comment">/**
 * Insert a new document in the index
 * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)
 * O(log(n))
 */</span>
Index.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{
  <span class="hljs-keyword">var</span> key, self = <span class="hljs-keyword">this</span>
    , keys, i, failingI, error
    ;

  <span class="hljs-keyword">if</span> (util.isArray(doc)) { <span class="hljs-keyword">this</span>.insertMultipleDocs(doc); <span class="hljs-keyword">return</span>; }

  key = model.getDotValue(doc, <span class="hljs-keyword">this</span>.fieldName);</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>We don’t index documents that don’t contain the field if the index is sparse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (key === <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">this</span>.sparse) { <span class="hljs-keyword">return</span>; }

  <span class="hljs-keyword">if</span> (!util.isArray(key)) {
    <span class="hljs-keyword">this</span>.tree.insert(key, doc);
  } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>If an insert fails due to a unique constraint, roll back all inserts before it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    keys = _.uniq(key, projectForUnique);

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; keys.length; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">this</span>.tree.insert(keys[i], doc);
      } <span class="hljs-keyword">catch</span> (e) {
        error = e;
        failingI = i;
        <span class="hljs-keyword">break</span>;
      }
    }
    
    <span class="hljs-keyword">if</span> (error) {
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; failingI; i += <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">this</span>.tree.delete(keys[i], doc);
      }
      
      <span class="hljs-keyword">throw</span> error;
    }
  }
};


<span class="hljs-comment">/**
 * Insert an array of documents in the index
 * If a constraint is violated, the changes should be rolled back and an error thrown
 *
 * @API private
 */</span>
Index.prototype.insertMultipleDocs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(docs)</span> </span>{
  <span class="hljs-keyword">var</span> i, error, failingI;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; docs.length; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.insert(docs[i]);
    } <span class="hljs-keyword">catch</span> (e) {
      error = e;
      failingI = i;
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; failingI; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.remove(docs[i]);
    }

    <span class="hljs-keyword">throw</span> error;
  }
};


<span class="hljs-comment">/**
 * Remove a document from the index
 * If an array is passed, we remove all its elements
 * The remove operation is safe with regards to the 'unique' constraint
 * O(log(n))
 */</span>
Index.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{
  <span class="hljs-keyword">var</span> key, self = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">if</span> (util.isArray(doc)) { doc.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(d)</span> </span>{ self.remove(d); }); <span class="hljs-keyword">return</span>; }

  key = model.getDotValue(doc, <span class="hljs-keyword">this</span>.fieldName);

  <span class="hljs-keyword">if</span> (key === <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">this</span>.sparse) { <span class="hljs-keyword">return</span>; }

  <span class="hljs-keyword">if</span> (!util.isArray(key)) {
    <span class="hljs-keyword">this</span>.tree.delete(key, doc);
  } <span class="hljs-keyword">else</span> {
    _.uniq(key, projectForUnique).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_key)</span> </span>{
      self.tree.delete(_key, doc);
    });
  }
};


<span class="hljs-comment">/**
 * Update a document in the index
 * If a constraint is violated, changes are rolled back and an error thrown
 * Naive implementation, still in O(log(n))
 */</span>
Index.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(oldDoc, newDoc)</span> </span>{
  <span class="hljs-keyword">if</span> (util.isArray(oldDoc)) { <span class="hljs-keyword">this</span>.updateMultipleDocs(oldDoc); <span class="hljs-keyword">return</span>; }

  <span class="hljs-keyword">this</span>.remove(oldDoc);

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">this</span>.insert(newDoc);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">this</span>.insert(oldDoc);
    <span class="hljs-keyword">throw</span> e;
  }
};


<span class="hljs-comment">/**
 * Update multiple documents in the index
 * If a constraint is violated, the changes need to be rolled back
 * and an error thrown
 * @param {Array of oldDoc, newDoc pairs} pairs
 *
 * @API private
 */</span>
Index.prototype.updateMultipleDocs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pairs)</span> </span>{
  <span class="hljs-keyword">var</span> i, failingI, error;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pairs.length; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">this</span>.remove(pairs[i].oldDoc);
  }

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pairs.length; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.insert(pairs[i].newDoc);
    } <span class="hljs-keyword">catch</span> (e) {
      error = e;
      failingI = i;
      <span class="hljs-keyword">break</span>;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>If an error was raised, roll back changes in the inverse order</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; failingI; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.remove(pairs[i].newDoc);
    }

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pairs.length; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.insert(pairs[i].oldDoc);
    }

    <span class="hljs-keyword">throw</span> error;
  }
};


<span class="hljs-comment">/**
 * Revert an update
 */</span>
Index.prototype.revertUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(oldDoc, newDoc)</span> </span>{
  <span class="hljs-keyword">var</span> revert = [];

  <span class="hljs-keyword">if</span> (!util.isArray(oldDoc)) {
    <span class="hljs-keyword">this</span>.update(newDoc, oldDoc);
  } <span class="hljs-keyword">else</span> {
    oldDoc.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pair)</span> </span>{
      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });
    });
    <span class="hljs-keyword">this</span>.update(revert);
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Append all elements in toAppend to array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">append</span> <span class="hljs-params">(array, toAppend)</span> </span>{
  <span class="hljs-keyword">var</span> i;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; toAppend.length; i += <span class="hljs-number">1</span>) {
    array.push(toAppend[i]);
  }
}


<span class="hljs-comment">/**
 * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)
 * @param {Thing} value Value to match the key against
 * @return {Array of documents}
 */</span>
Index.prototype.getMatching = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
  <span class="hljs-keyword">var</span> res, self = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">if</span> (!util.isArray(value)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tree.search(value);
  } <span class="hljs-keyword">else</span> {
    res = [];
    value.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(v)</span> </span>{ append(res, self.getMatching(v)); });
    <span class="hljs-keyword">return</span> res;
  }
};


<span class="hljs-comment">/**
 * Get all documents in index whose key is between bounds are they are defined by query
 * Documents are sorted by key
 * @param {Query} query
 * @return {Array of documents}
 */</span>
Index.prototype.getBetweenBounds = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tree.betweenBounds(query);
};


<span class="hljs-comment">/**
 * Get all elements in the index
 * @return {Array of documents}
 */</span>
Index.prototype.getAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> res = [];

  <span class="hljs-keyword">this</span>.tree.executeOnEveryNode(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">var</span> i;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; node.data.length; i += <span class="hljs-number">1</span>) {
      res.push(node.data[i]);
    }
  });

  <span class="hljs-keyword">return</span> res;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Interface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">module</span>.exports = Index;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
