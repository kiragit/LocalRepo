<!DOCTYPE html>

<html>
<head>
  <title>datastore.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>datastore.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> customUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./customUtils'</span>)
  , model = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./model'</span>)
  , async = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>)
  , Executor = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./executor'</span>)
  , Index = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./indexes'</span>)
  , util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>)
  , _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>)
  , Persistence = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./persistence'</span>)
  , Cursor = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cursor'</span>)
  ;


<span class="hljs-comment">/**
 * Create a new collection
 * @param {String} options.filename Optional, datastore will be in-memory only if not provided
 * @param {Boolean} options.inMemoryOnly Optional, default to false
 * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where
 *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)
 * @param {Boolean} options.autoload Optional, defaults to false
 * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Datastore</span> <span class="hljs-params">(options)</span> </span>{
  <span class="hljs-keyword">var</span> filename;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Retrocompatibility with v0.6 and before</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>) {
    filename = options;
    <span class="hljs-keyword">this</span>.inMemoryOnly = <span class="hljs-literal">false</span>;   <span class="hljs-comment">// Default</span>
  } <span class="hljs-keyword">else</span> {
    options = options || {};
    filename = options.filename;
    <span class="hljs-keyword">this</span>.inMemoryOnly = options.inMemoryOnly || <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.autoload = options.autoload || <span class="hljs-literal">false</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Determine whether in memory or persistent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (!filename || <span class="hljs-keyword">typeof</span> filename !== <span class="hljs-string">'string'</span> || filename.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.filename = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.inMemoryOnly = <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.filename = filename;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Persistence handling</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.persistence = <span class="hljs-keyword">new</span> Persistence({ db: <span class="hljs-keyword">this</span>, nodeWebkitAppName: options.nodeWebkitAppName });</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>This new executor is ready if we donâ€™t use persistence
If we do, it will only be ready once loadDatabase is called</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.executor = <span class="hljs-keyword">new</span> Executor();
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.inMemoryOnly) { <span class="hljs-keyword">this</span>.executor.ready = <span class="hljs-literal">true</span>; }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Indexed by field name, dot notation can be used
_id is always indexed and since _ids are generated randomly the underlying
binary is always well-balanced</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.indexes = {};
  <span class="hljs-keyword">this</span>.indexes._id = <span class="hljs-keyword">new</span> Index({ fieldName: <span class="hljs-string">'_id'</span>, unique: <span class="hljs-literal">true</span> });</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Queue a load of the database right away and call the onload handler
By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autoload) { <span class="hljs-keyword">this</span>.loadDatabase(options.onload || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">throw</span> err; }
  }); }
}


<span class="hljs-comment">/**
 * Load the database from the datafile, and trigger the execution of buffered commands if any
 */</span>
Datastore.prototype.loadDatabase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.executor.push({ <span class="hljs-keyword">this</span>: <span class="hljs-keyword">this</span>.persistence, fn: <span class="hljs-keyword">this</span>.persistence.loadDatabase, <span class="hljs-built_in">arguments</span>: <span class="hljs-built_in">arguments</span> }, <span class="hljs-literal">true</span>);
};


<span class="hljs-comment">/**
 * Get an array of all the data in the database
 */</span>
Datastore.prototype.getAllData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.indexes._id.getAll();
};


<span class="hljs-comment">/**
 * Reset all currently defined indexes
 */</span>
Datastore.prototype.resetIndexes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newData)</span> </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

  <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.indexes).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> </span>{
    self.indexes[i].reset(newData);
  });
};


<span class="hljs-comment">/**
 * Ensure an index is kept for this field. Same parameters as lib/indexes
 * For now this function is synchronous, we need to test how much time it takes
 * We use an async API for consistency with the rest of the code
 * @param {String} options.fieldName
 * @param {Boolean} options.unique
 * @param {Boolean} options.sparse
 * @param {Function} cb Optional callback, signature: err
 */</span>
Datastore.prototype.ensureIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options, cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{};

  options = options || {};

  <span class="hljs-keyword">if</span> (!options.fieldName) { <span class="hljs-keyword">return</span> callback({ missingFieldName: <span class="hljs-literal">true</span> }); }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.indexes[options.fieldName]) { <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>); }

  <span class="hljs-keyword">this</span>.indexes[options.fieldName] = <span class="hljs-keyword">new</span> Index(options);

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">this</span>.indexes[options.fieldName].insert(<span class="hljs-keyword">this</span>.getAllData());
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.indexes[options.fieldName];
    <span class="hljs-keyword">return</span> callback(e);
  }

  <span class="hljs-keyword">this</span>.persistence.persistNewState([{ $$indexCreated: options }], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>);
  });
};


<span class="hljs-comment">/**
 * Remove an index
 * @param {String} fieldName
 * @param {Function} cb Optional callback, signature: err 
 */</span>
Datastore.prototype.removeIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fieldName, cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{};
  
  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.indexes[fieldName];
  
  <span class="hljs-keyword">this</span>.persistence.persistNewState([{ $$indexRemoved: fieldName }], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>);
  });  
};


<span class="hljs-comment">/**
 * Add one or several document(s) to all indexes
 */</span>
Datastore.prototype.addToIndexes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{
  <span class="hljs-keyword">var</span> i, failingIndex, error
    , keys = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.indexes)
    ;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; keys.length; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.indexes[keys[i]].insert(doc);
    } <span class="hljs-keyword">catch</span> (e) {
      failingIndex = i;
      error = e;
      <span class="hljs-keyword">break</span>;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>If an error happened, we need to rollback the insert on all other indexes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; failingIndex; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.indexes[keys[i]].remove(doc);
    }

    <span class="hljs-keyword">throw</span> error;
  }
};


<span class="hljs-comment">/**
 * Remove one or several document(s) from all indexes
 */</span>
Datastore.prototype.removeFromIndexes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

  <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.indexes).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> </span>{
    self.indexes[i].remove(doc);
  });
};


<span class="hljs-comment">/**
 * Update one or several documents in all indexes
 * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs
 * If one update violates a constraint, all changes are rolled back
 */</span>
Datastore.prototype.updateIndexes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(oldDoc, newDoc)</span> </span>{
  <span class="hljs-keyword">var</span> i, failingIndex, error
    , keys = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.indexes)
    ;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; keys.length; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.indexes[keys[i]].update(oldDoc, newDoc);
    } <span class="hljs-keyword">catch</span> (e) {
      failingIndex = i;
      error = e;
      <span class="hljs-keyword">break</span>;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>If an error happened, we need to rollback the update on all other indexes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; failingIndex; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.indexes[keys[i]].revertUpdate(oldDoc, newDoc);
    }

    <span class="hljs-keyword">throw</span> error;
  }
};


<span class="hljs-comment">/**
 * Return the list of candidates for a given query
 * Crude implementation for now, we return the candidates given by the first usable index if any
 * We try the following query types, in this order: basic match, $in match, comparison match
 * One way to make it better would be to enable the use of multiple indexes if the first usable index
 * returns too much data. I may do it in the future.
 *
 * TODO: needs to be moved to the Cursor module
 */</span>
Datastore.prototype.getCandidates = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query)</span> </span>{
  <span class="hljs-keyword">var</span> indexNames = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.indexes)
    , usableQueryKeys;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>For a basic match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  usableQueryKeys = [];
  <span class="hljs-built_in">Object</span>.keys(query).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> query[k] === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> query[k] === <span class="hljs-string">'number'</span> || <span class="hljs-keyword">typeof</span> query[k] === <span class="hljs-string">'boolean'</span> || util.isDate(query[k]) || query[k] === <span class="hljs-literal">null</span>) {
      usableQueryKeys.push(k);
    }
  });
  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
  <span class="hljs-keyword">if</span> (usableQueryKeys.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.indexes[usableQueryKeys[<span class="hljs-number">0</span>]].getMatching(query[usableQueryKeys[<span class="hljs-number">0</span>]]);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>For a $in match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  usableQueryKeys = [];
  <span class="hljs-built_in">Object</span>.keys(query).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
    <span class="hljs-keyword">if</span> (query[k] &amp;&amp; query[k].hasOwnProperty(<span class="hljs-string">'$in'</span>)) {
      usableQueryKeys.push(k);
    }
  });
  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
  <span class="hljs-keyword">if</span> (usableQueryKeys.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.indexes[usableQueryKeys[<span class="hljs-number">0</span>]].getMatching(query[usableQueryKeys[<span class="hljs-number">0</span>]].$<span class="hljs-keyword">in</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>For a comparison match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  usableQueryKeys = [];
  <span class="hljs-built_in">Object</span>.keys(query).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
    <span class="hljs-keyword">if</span> (query[k] &amp;&amp; (query[k].hasOwnProperty(<span class="hljs-string">'$lt'</span>) || query[k].hasOwnProperty(<span class="hljs-string">'$lte'</span>) || query[k].hasOwnProperty(<span class="hljs-string">'$gt'</span>) || query[k].hasOwnProperty(<span class="hljs-string">'$gte'</span>))) {
      usableQueryKeys.push(k);
    }
  });
  usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
  <span class="hljs-keyword">if</span> (usableQueryKeys.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.indexes[usableQueryKeys[<span class="hljs-number">0</span>]].getBetweenBounds(query[usableQueryKeys[<span class="hljs-number">0</span>]]);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>By default, return all the DB data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAllData();
};


<span class="hljs-comment">/**
 * Insert a new document
 * @param {Function} cb Optional callback, signature: err, insertedDoc
 *
 * @api private Use Datastore.insert which has the same signature
 */</span>
Datastore.prototype._insert = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newDoc, cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{}
    ;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">this</span>._insertInCache(newDoc);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">return</span> callback(e);
  }

  <span class="hljs-keyword">this</span>.persistence.persistNewState(util.isArray(newDoc) ? newDoc : [newDoc], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, newDoc);
  });
};

<span class="hljs-comment">/**
 * Prepare a document (or array of documents) to be inserted in a database
 * @api private
 */</span>
Datastore.prototype.prepareDocumentForInsertion = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newDoc)</span> </span>{
  <span class="hljs-keyword">var</span> preparedDoc, self = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">if</span> (util.isArray(newDoc)) {
    preparedDoc = [];
    newDoc.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{ preparedDoc.push(self.prepareDocumentForInsertion(doc)); });
  } <span class="hljs-keyword">else</span> {
    newDoc._id = newDoc._id || customUtils.uid(<span class="hljs-number">16</span>);
    preparedDoc = model.deepCopy(newDoc);
    model.checkObject(preparedDoc);
  }
  
  <span class="hljs-keyword">return</span> preparedDoc;
};

<span class="hljs-comment">/**
 * If newDoc is an array of documents, this will insert all documents in the cache
 * @api private
 */</span>
Datastore.prototype._insertInCache = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newDoc)</span> </span>{
  <span class="hljs-keyword">if</span> (util.isArray(newDoc)) {
    <span class="hljs-keyword">this</span>._insertMultipleDocsInCache(newDoc);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.addToIndexes(<span class="hljs-keyword">this</span>.prepareDocumentForInsertion(newDoc));  
  }
};

<span class="hljs-comment">/**
 * If one insertion fails (e.g. because of a unique constraint), roll back all previous
 * inserts and throws the error
 * @api private
 */</span>
Datastore.prototype._insertMultipleDocsInCache = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newDocs)</span> </span>{
  <span class="hljs-keyword">var</span> i, failingI, error
    , preparedDocs = <span class="hljs-keyword">this</span>.prepareDocumentForInsertion(newDocs)
    ;
  
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; preparedDocs.length; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.addToIndexes(preparedDocs[i]);
    } <span class="hljs-keyword">catch</span> (e) {
      error = e;
      failingI = i;
      <span class="hljs-keyword">break</span>;
    }
  }
  
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; failingI; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.removeFromIndexes(preparedDocs[i]);
    }
    
    <span class="hljs-keyword">throw</span> error;
  }
};

Datastore.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.executor.push({ <span class="hljs-keyword">this</span>: <span class="hljs-keyword">this</span>, fn: <span class="hljs-keyword">this</span>._insert, <span class="hljs-built_in">arguments</span>: <span class="hljs-built_in">arguments</span> });
};


<span class="hljs-comment">/**
 * Count all documents matching the query
 * @param {Object} query MongoDB-style query
 */</span>
Datastore.prototype.count = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(query, callback)</span> </span>{
  <span class="hljs-keyword">var</span> cursor = <span class="hljs-keyword">new</span> Cursor(<span class="hljs-keyword">this</span>, query, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, docs, callback)</span> </span>{
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, docs.length);
  });

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
    cursor.exec(callback);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> cursor;
  }
};


<span class="hljs-comment">/**
 * Find all documents matching the query
 * If no callback is passed, we return the cursor so that user can limit, skip and finally exec
 * @param {Object} query MongoDB-style query
 */</span>
Datastore.prototype.find = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, callback)</span> </span>{
  <span class="hljs-keyword">var</span> cursor = <span class="hljs-keyword">new</span> Cursor(<span class="hljs-keyword">this</span>, query, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, docs, callback)</span> </span>{
    <span class="hljs-keyword">var</span> res = [], i;
  
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
    
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; docs.length; i += <span class="hljs-number">1</span>) {
      res.push(model.deepCopy(docs[i]));
    }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, res);
  });

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
    cursor.exec(callback);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> cursor;
  }
};


<span class="hljs-comment">/**
 * Find one document matching the query
 * @param {Object} query MongoDB-style query
 */</span>
Datastore.prototype.findOne = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, callback)</span> </span>{
  <span class="hljs-keyword">var</span> cursor = <span class="hljs-keyword">new</span> Cursor(<span class="hljs-keyword">this</span>, query, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, docs, callback)</span> </span>{
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
    <span class="hljs-keyword">if</span> (docs.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, model.deepCopy(docs[<span class="hljs-number">0</span>]));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);    
    }
  });

  cursor.limit(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
    cursor.exec(callback);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> cursor;
  }
};


<span class="hljs-comment">/**
 * Update all docs matching query
 * For now, very naive implementation (recalculating the whole database)
 * @param {Object} query
 * @param {Object} updateQuery
 * @param {Object} options Optional options
 *                 options.multi If true, can update multiple documents (defaults to false)
 *                 options.upsert If true, document is inserted if the query doesn't match anything
 * @param {Function} cb Optional callback, signature: err, numReplaced, upsert (set to true if the update was in fact an upsert)
 *
 * @api private Use Datastore.update which has the same signature
 */</span>
Datastore.prototype._update = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, updateQuery, options, cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback
    , self = <span class="hljs-keyword">this</span>
    , numReplaced = <span class="hljs-number">0</span>
    , multi, upsert
    , i
    ;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'function'</span>) { cb = options; options = {}; }
  callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{};
  multi = options.multi !== <span class="hljs-literal">undefined</span> ? options.multi : <span class="hljs-literal">false</span>;
  upsert = options.upsert !== <span class="hljs-literal">undefined</span> ? options.upsert : <span class="hljs-literal">false</span>;

  async.waterfall([
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{   <span class="hljs-comment">// If upsert option is set, check whether we need to insert the doc</span>
    <span class="hljs-keyword">if</span> (!upsert) { <span class="hljs-keyword">return</span> cb(); }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Need to use an internal function not tied to the executor to avoid deadlock</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> cursor = <span class="hljs-keyword">new</span> Cursor(self, query);
    cursor.limit(<span class="hljs-number">1</span>)._exec(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, docs)</span> </span>{
      <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
      <span class="hljs-keyword">if</span> (docs.length === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> cb();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> self._insert(model.modify(query, updateQuery), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, newDoc)</span> </span>{
          <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
          <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, newDoc);
        });
      }
    });
  }
  , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{   <span class="hljs-comment">// Perform the update</span>
    <span class="hljs-keyword">var</span> modifiedDoc
	  , candidates = self.getCandidates(query)
	  , modifications = []
	  ;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Preparing update (if an error is thrown here neither the datafile nor
the in-memory indexes are affected)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; candidates.length; i += <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (model.match(candidates[i], query) &amp;&amp; (multi || numReplaced === <span class="hljs-number">0</span>)) {
          numReplaced += <span class="hljs-number">1</span>;
          modifiedDoc = model.modify(candidates[i], updateQuery);
          modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });
        }
      }
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">return</span> callback(err);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Change the docs in memory</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">try</span> {
      self.updateIndexes(modifications);
	} <span class="hljs-keyword">catch</span> (err) {
	  <span class="hljs-keyword">return</span> callback(err);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Update the datafile</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    self.persistence.persistNewState(_.pluck(modifications, <span class="hljs-string">'newDoc'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
      <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
      <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, numReplaced);
    });
  }
  ]);
};
Datastore.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.executor.push({ <span class="hljs-keyword">this</span>: <span class="hljs-keyword">this</span>, fn: <span class="hljs-keyword">this</span>._update, <span class="hljs-built_in">arguments</span>: <span class="hljs-built_in">arguments</span> });
};


<span class="hljs-comment">/**
 * Remove all docs matching the query
 * For now very naive implementation (similar to update)
 * @param {Object} query
 * @param {Object} options Optional options
 *                 options.multi If true, can update multiple documents (defaults to false)
 * @param {Function} cb Optional callback, signature: err, numRemoved
 *
 * @api private Use Datastore.remove which has the same signature
 */</span>
Datastore.prototype._remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(query, options, cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback
    , self = <span class="hljs-keyword">this</span>
    , numRemoved = <span class="hljs-number">0</span>
    , multi
    , removedDocs = []
    , candidates = <span class="hljs-keyword">this</span>.getCandidates(query)
    ;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'function'</span>) { cb = options; options = {}; }
  callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{};
  multi = options.multi !== <span class="hljs-literal">undefined</span> ? options.multi : <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">try</span> {
    candidates.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(d)</span> </span>{
      <span class="hljs-keyword">if</span> (model.match(d, query) &amp;&amp; (multi || numRemoved === <span class="hljs-number">0</span>)) {
        numRemoved += <span class="hljs-number">1</span>;
        removedDocs.push({ $$deleted: <span class="hljs-literal">true</span>, _id: d._id });
        self.removeFromIndexes(d);
      }
    });
  } <span class="hljs-keyword">catch</span> (err) { <span class="hljs-keyword">return</span> callback(err); }

  self.persistence.persistNewState(removedDocs, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, numRemoved);
  });
};
Datastore.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.executor.push({ <span class="hljs-keyword">this</span>: <span class="hljs-keyword">this</span>, fn: <span class="hljs-keyword">this</span>._remove, <span class="hljs-built_in">arguments</span>: <span class="hljs-built_in">arguments</span> });
};



<span class="hljs-built_in">module</span>.exports = Datastore;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
