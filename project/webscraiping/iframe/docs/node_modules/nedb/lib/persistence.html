<!DOCTYPE html>

<html>
<head>
  <title>persistence.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>persistence.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * Handle every persistence-related task
 * The interface Datastore expects to be implemented is
 * * Persistence.loadDatabase(callback) and callback has signature err
 * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err
 */</span>

<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
  , path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
  , model = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./model'</span>)
  , async = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>)
  , mkdirp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mkdirp'</span>)
  , customUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./customUtils'</span>)
  , Index = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./indexes'</span>)
  ;


<span class="hljs-comment">/**
 * Create a new Persistence object for database options.db
 * @param {Datastore} options.db
 * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where
 *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Persistence</span> <span class="hljs-params">(options)</span> </span>{
  <span class="hljs-keyword">this</span>.db = options.db;
  <span class="hljs-keyword">this</span>.inMemoryOnly = <span class="hljs-keyword">this</span>.db.inMemoryOnly;
  <span class="hljs-keyword">this</span>.filename = <span class="hljs-keyword">this</span>.db.filename;
  
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inMemoryOnly &amp;&amp; <span class="hljs-keyword">this</span>.filename) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.filename.charAt(<span class="hljs-keyword">this</span>.filename.length - <span class="hljs-number">1</span>) === <span class="hljs-string">'~'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-string">"The datafile name can't end with a ~, which is reserved for automatic backup files"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.tempFilename = <span class="hljs-keyword">this</span>.filename + <span class="hljs-string">'~'</span>;
      <span class="hljs-keyword">this</span>.oldFilename = <span class="hljs-keyword">this</span>.filename + <span class="hljs-string">'~~'</span>;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>For NW apps, store data in the same directory where NW stores application data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.filename &amp;&amp; options.nodeWebkitAppName) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=================================================================="</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"WARNING: The nodeWebkitAppName option is deprecated"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"To get the path to the directory where Node Webkit stores the data"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"for your app, use the internal nw.gui module like this"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"require('nw.gui').App.dataPath"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"See https://github.com/rogerwang/node-webkit/issues/500"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=================================================================="</span>);
    <span class="hljs-keyword">this</span>.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, <span class="hljs-keyword">this</span>.filename);
    <span class="hljs-keyword">this</span>.tempFilename = Persistence.getNWAppFilename(options.nodeWebkitAppName, <span class="hljs-keyword">this</span>.tempFilename);
    <span class="hljs-keyword">this</span>.oldFilename = Persistence.getNWAppFilename(options.nodeWebkitAppName, <span class="hljs-keyword">this</span>.oldFilename);
  }
};


<span class="hljs-comment">/**
 * Check if a directory exists and create it on the fly if it is not the case
 * cb is optional, signature: err
 */</span>
Persistence.ensureDirectoryExists = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(dir, cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{}
    ;

  mkdirp(dir, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{ <span class="hljs-keyword">return</span> callback(err); });
};


<span class="hljs-comment">/**
 * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores
 * data for this application. Probably the best place to store data
 */</span>
Persistence.getNWAppFilename = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(appName, relativeFilename)</span> </span>{
  <span class="hljs-keyword">var</span> home;

  <span class="hljs-keyword">switch</span> (process.platform) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'win32'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'win64'</span>:
      home = process.env.LOCALAPPDATA || process.env.APPDATA;
      <span class="hljs-keyword">if</span> (!home) { <span class="hljs-keyword">throw</span> <span class="hljs-string">"Couldn't find the base application data folder"</span>; }
      home = path.join(home, appName);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'darwin'</span>:
      home = process.env.HOME;
      <span class="hljs-keyword">if</span> (!home) { <span class="hljs-keyword">throw</span> <span class="hljs-string">"Couldn't find the base application data directory"</span>; }
      home = path.join(home, <span class="hljs-string">'Library'</span>, <span class="hljs-string">'Application Support'</span>, appName);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'linux'</span>:
      home = process.env.HOME;
      <span class="hljs-keyword">if</span> (!home) { <span class="hljs-keyword">throw</span> <span class="hljs-string">"Couldn't find the base application data directory"</span>; }
      home = path.join(home, <span class="hljs-string">'.config'</span>, appName);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-string">"Can't use the Node Webkit relative path for platform "</span> + process.platform;
      <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-keyword">return</span> path.join(home, <span class="hljs-string">'nedb-data'</span>, relativeFilename);
}


<span class="hljs-comment">/**
 * Persist cached database
 * This serves as a compaction function since the cache always contains only the number of documents in the collection
 * while the data file is append-only so it may grow larger
 * @param {Function} cb Optional callback, signature: err
 */</span>
Persistence.prototype.persistCachedDatabase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{}
    , toPersist = <span class="hljs-string">''</span>
    , self = <span class="hljs-keyword">this</span>
    ;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.inMemoryOnly) { <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>); } 

  <span class="hljs-keyword">this</span>.db.getAllData().forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{
    toPersist += model.serialize(doc) + <span class="hljs-string">'\n'</span>;
  });
  <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.db.indexes).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fieldName)</span> </span>{
    <span class="hljs-keyword">if</span> (fieldName != <span class="hljs-string">"_id"</span>) {   <span class="hljs-comment">// The special _id index is managed by datastore.js, the others need to be persisted</span>
      toPersist += model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }}) + <span class="hljs-string">'\n'</span>;
    }
  });

  async.waterfall([
    async.apply(customUtils.ensureFileDoesntExist, self.tempFilename)
  , async.apply(customUtils.ensureFileDoesntExist, self.oldFilename)
  , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
      fs.exists(self.filename, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exists)</span> </span>{
        <span class="hljs-keyword">if</span> (exists) {
          fs.rename(self.filename, self.oldFilename, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{ <span class="hljs-keyword">return</span> cb(err); });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> cb();
        }
      });  
  }
  , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
      fs.writeFile(self.tempFilename, toPersist, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{ <span class="hljs-keyword">return</span> cb(err); });
    }
  , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
      fs.rename(self.tempFilename, self.filename, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{ <span class="hljs-keyword">return</span> cb(err); });
    }
  , async.apply(customUtils.ensureFileDoesntExist, self.oldFilename)
  ], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{ <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); } <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>); } })
};


<span class="hljs-comment">/**
 * Queue a rewrite of the datafile
 */</span>
Persistence.prototype.compactDatafile = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.db.executor.push({ <span class="hljs-keyword">this</span>: <span class="hljs-keyword">this</span>, fn: <span class="hljs-keyword">this</span>.persistCachedDatabase, <span class="hljs-built_in">arguments</span>: [] });
};


<span class="hljs-comment">/**
 * Set automatic compaction every interval ms
 * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds
 */</span>
Persistence.prototype.setAutocompactionInterval = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(interval)</span> </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
    , minInterval = <span class="hljs-number">5000</span>
    , realInterval = <span class="hljs-built_in">Math</span>.max(interval || <span class="hljs-number">0</span>, minInterval)
    ;

  <span class="hljs-keyword">this</span>.stopAutocompaction();

  <span class="hljs-keyword">this</span>.autocompactionIntervalId = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    self.compactDatafile();
  }, realInterval);
};


<span class="hljs-comment">/**
 * Stop autocompaction (do nothing if autocompaction was not running)
 */</span>
Persistence.prototype.stopAutocompaction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autocompactionIntervalId) { clearInterval(<span class="hljs-keyword">this</span>.autocompactionIntervalId); }
};


<span class="hljs-comment">/**
 * Persist new state for the given newDocs (can be insertion, update or removal)
 * Use an append-only format
 * @param {Array} newDocs Can be empty if no doc was updated/removed
 * @param {Function} cb Optional, signature: err
 */</span>
Persistence.prototype.persistNewState = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newDocs, cb)</span> </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
    , toPersist = <span class="hljs-string">''</span>
    , callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{}
    ;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>In-memory only datastore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (self.inMemoryOnly) { <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>); }

  newDocs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{
    toPersist += model.serialize(doc) + <span class="hljs-string">'\n'</span>;
  });

  <span class="hljs-keyword">if</span> (toPersist.length === <span class="hljs-number">0</span>) { <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>); }

  fs.appendFile(self.filename, toPersist, <span class="hljs-string">'utf8'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-keyword">return</span> callback(err);
  });
};


<span class="hljs-comment">/**
 * From a database's raw data, return the corresponding
 * machine understandable collection
 */</span>
Persistence.treatRawData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(rawData)</span> </span>{
  <span class="hljs-keyword">var</span> data = rawData.split(<span class="hljs-string">'\n'</span>)
    , dataById = {}
    , tdata = []
    , i
    , indexes = {}
    ;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; data.length; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">var</span> doc;

    <span class="hljs-keyword">try</span> {
      doc = model.deserialize(data[i]);
      <span class="hljs-keyword">if</span> (doc._id) {
        <span class="hljs-keyword">if</span> (doc.$$deleted === <span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">delete</span> dataById[doc._id];
        } <span class="hljs-keyword">else</span> {
          dataById[doc._id] = doc;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (doc.$$indexCreated &amp;&amp; doc.$$indexCreated.fieldName != <span class="hljs-literal">undefined</span>) {
        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> doc.$$indexRemoved === <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">delete</span> indexes[doc.$$indexRemoved];
      }
    } <span class="hljs-keyword">catch</span> (e) {
    }
  }

  <span class="hljs-built_in">Object</span>.keys(dataById).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
    tdata.push(dataById[k]);
  });

  <span class="hljs-keyword">return</span> { data: tdata, indexes: indexes };
};


<span class="hljs-comment">/**
 * Ensure that this.filename contains the most up-to-date version of the data
 * Even if a loadDatabase crashed before
 */</span>
Persistence.prototype.ensureDatafileIntegrity = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>  ;

  fs.exists(self.filename, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filenameExists)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Write was successful</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (filenameExists) { <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>); }
  
    fs.exists(self.oldFilename, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(oldFilenameExists)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>New database</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!oldFilenameExists) {
        <span class="hljs-keyword">return</span> fs.writeFile(self.filename, <span class="hljs-string">''</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{ callback(err); });            
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Write failed, use old version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      fs.rename(self.oldFilename, self.filename, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{ <span class="hljs-keyword">return</span> callback(err); });
    });
  });
};


<span class="hljs-comment">/**
 * Load the database
 * 1) Create all indexes
 * 2) Insert all data
 * 3) Compact the database
 * This means pulling data out of the data file or creating it if it doesn't exist
 * Also, all data is persisted right away, which has the effect of compacting the database file
 * This operation is very quick at startup for a big collection (60ms for ~10k docs)
 * @param {Function} cb Optional callback, signature: err
 */</span>
Persistence.prototype.loadDatabase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
  <span class="hljs-keyword">var</span> callback = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{}
    , self = <span class="hljs-keyword">this</span>
    ;

  self.db.resetIndexes();</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>In-memory only datastore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (self.inMemoryOnly) { <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>); }

  async.waterfall([
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
      Persistence.ensureDirectoryExists(path.dirname(self.filename), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
        self.ensureDatafileIntegrity(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exists)</span> </span>{
          fs.readFile(self.filename, <span class="hljs-string">'utf8'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, rawData)</span> </span>{
            <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> cb(err); }
            <span class="hljs-keyword">var</span> treatedData = Persistence.treatRawData(rawData);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Recreate all indexes in the datafile</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">Object</span>.keys(treatedData.indexes).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key)</span> </span>{
              self.db.indexes[key] = <span class="hljs-keyword">new</span> Index(treatedData.indexes[key]);
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Fill cached database (i.e. all indexes) with data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">try</span> {
              self.db.resetIndexes(treatedData.data);
            } <span class="hljs-keyword">catch</span> (e) {
              self.db.resetIndexes();   <span class="hljs-comment">// Rollback any index which didn't fail</span>
              <span class="hljs-keyword">return</span> cb(e);
            }

            self.db.persistence.persistCachedDatabase(cb);
          });
        });
      });
    }
  ], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
       <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }

       self.db.executor.processBuffer();
       <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>);
     });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Interface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">module</span>.exports = Persistence;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
