<!DOCTYPE html>

<html>
<head>
  <title>bst.test.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>bst.test.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> should = <span class="hljs-built_in">require</span>(<span class="hljs-string">'chai'</span>).should()
  , assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'chai'</span>).assert
  , BinarySearchTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../index'</span>).BinarySearchTree
  , _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>)
  , customUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/customUtils'</span>)
  ;


describe(<span class="hljs-string">'Binary search tree'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

  it(<span class="hljs-string">'Upon creation, left, right are null, key and data can be set'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();
    assert.isNull(bst.left);
    assert.isNull(bst.right);
    bst.hasOwnProperty(<span class="hljs-string">'key'</span>).should.equal(<span class="hljs-literal">false</span>);
    bst.data.length.should.equal(<span class="hljs-number">0</span>);

    bst = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">6</span>, value: <span class="hljs-string">'ggg'</span> });
    assert.isNull(bst.left);
    assert.isNull(bst.right);
    bst.key.should.equal(<span class="hljs-number">6</span>);
    bst.data.length.should.equal(<span class="hljs-number">1</span>);
    bst.data[<span class="hljs-number">0</span>].should.equal(<span class="hljs-string">'ggg'</span>);
  });

  describe(<span class="hljs-string">'Sanity checks'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

    it(<span class="hljs-string">'Can get maxkey and minkey descendants'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">10</span> })
        , l = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">5</span> })
        , r = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">15</span> })
        , ll = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">3</span> })
        , lr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">8</span> })
        , rl = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">11</span> })
        , rr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">42</span> })
        ;

      t.left = l; t.right = r;
      l.left = ll; l.right = lr;
      r.left = rl; r.right = rr;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Getting min and max key descendants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      t.getMinKeyDescendant().key.should.equal(<span class="hljs-number">3</span>);
      t.getMaxKeyDescendant().key.should.equal(<span class="hljs-number">42</span>);

      t.left.getMinKeyDescendant().key.should.equal(<span class="hljs-number">3</span>);
      t.left.getMaxKeyDescendant().key.should.equal(<span class="hljs-number">8</span>);

      t.right.getMinKeyDescendant().key.should.equal(<span class="hljs-number">11</span>);
      t.right.getMaxKeyDescendant().key.should.equal(<span class="hljs-number">42</span>);

      t.right.left.getMinKeyDescendant().key.should.equal(<span class="hljs-number">11</span>);
      t.right.left.getMaxKeyDescendant().key.should.equal(<span class="hljs-number">11</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Getting min and max keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      t.getMinKey().should.equal(<span class="hljs-number">3</span>);
      t.getMaxKey().should.equal(<span class="hljs-number">42</span>);

      t.left.getMinKey().should.equal(<span class="hljs-number">3</span>);
      t.left.getMaxKey().should.equal(<span class="hljs-number">8</span>);

      t.right.getMinKey().should.equal(<span class="hljs-number">11</span>);
      t.right.getMaxKey().should.equal(<span class="hljs-number">42</span>);

      t.right.left.getMinKey().should.equal(<span class="hljs-number">11</span>);
      t.right.left.getMaxKey().should.equal(<span class="hljs-number">11</span>);
    });

    it(<span class="hljs-string">'Can check a condition against every node in a tree'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">10</span> })
        , l = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">6</span> })
        , r = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">16</span> })
        , ll = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">4</span> })
        , lr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">8</span> })
        , rl = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">12</span> })
        , rr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">42</span> })
        ;

      t.left = l; t.right = r;
      l.left = ll; l.right = lr;
      r.left = rl; r.right = rr;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span> <span class="hljs-params">(k, v)</span> </span>{ <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-string">'Key is not even'</span>; } }

      t.checkAllNodesFullfillCondition(test);

      [l, r, ll, lr, rl, rr].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> </span>{
        node.key += <span class="hljs-number">1</span>;
        (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkAllNodesFullfillCondition(test); }).should.throw();
        node.key -= <span class="hljs-number">1</span>;
      });

      t.checkAllNodesFullfillCondition(test);
    });

    it(<span class="hljs-string">'Can check that a tree verifies node ordering'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">10</span> })
        , l = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">5</span> })
        , r = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">15</span> })
        , ll = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">3</span> })
        , lr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">8</span> })
        , rl = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">11</span> })
        , rr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">42</span> })
        ;

      t.left = l; t.right = r;
      l.left = ll; l.right = lr;
      r.left = rl; r.right = rr;

      t.checkNodeOrdering();</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Let’s be paranoid and check all cases…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      l.key = <span class="hljs-number">12</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      l.key = <span class="hljs-number">5</span>;

      r.key = <span class="hljs-number">9</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      r.key = <span class="hljs-number">15</span>;

      ll.key = <span class="hljs-number">6</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      ll.key = <span class="hljs-number">11</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      ll.key = <span class="hljs-number">3</span>;

      lr.key = <span class="hljs-number">4</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      lr.key = <span class="hljs-number">11</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      lr.key = <span class="hljs-number">8</span>;

      rl.key = <span class="hljs-number">16</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      rl.key = <span class="hljs-number">9</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      rl.key = <span class="hljs-number">11</span>;

      rr.key = <span class="hljs-number">12</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      rr.key = <span class="hljs-number">7</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      rr.key = <span class="hljs-number">10.5</span>;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkNodeOrdering(); }).should.throw();
      rr.key = <span class="hljs-number">42</span>;

      t.checkNodeOrdering();
    });

    it(<span class="hljs-string">'Checking if a tree\'s internal pointers (i.e. parents) are correct'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">10</span> })
        , l = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">5</span> })
        , r = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">15</span> })
        , ll = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">3</span> })
        , lr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">8</span> })
        , rl = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">11</span> })
        , rr = <span class="hljs-keyword">new</span> BinarySearchTree({ key: <span class="hljs-number">42</span> })
        ;

      t.left = l; t.right = r;
      l.left = ll; l.right = lr;
      r.left = rl; r.right = rr;

      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkInternalPointers(); }).should.throw();
      l.parent = t;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkInternalPointers(); }).should.throw();
      r.parent = t;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkInternalPointers(); }).should.throw();
      ll.parent = l;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkInternalPointers(); }).should.throw();
      lr.parent = l;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkInternalPointers(); }).should.throw();
      rl.parent = r;
      (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ t.checkInternalPointers(); }).should.throw();
      rr.parent = r;

      t.checkInternalPointers();
    });

    it(<span class="hljs-string">'Can get the number of inserted keys'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);
      bst.insert(<span class="hljs-number">10</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">1</span>);
      bst.insert(<span class="hljs-number">5</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
      bst.insert(<span class="hljs-number">3</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
      bst.insert(<span class="hljs-number">8</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);
      bst.insert(<span class="hljs-number">15</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">5</span>);
      bst.insert(<span class="hljs-number">12</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">6</span>);
      bst.insert(<span class="hljs-number">37</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
    });

  });

  describe(<span class="hljs-string">'Insertion'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

    it(<span class="hljs-string">'Insert at the root if its the first insertion'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'some data'</span>);

      bst.checkIsBST();
      bst.key.should.equal(<span class="hljs-number">10</span>);
      _.isEqual(bst.data, [<span class="hljs-string">'some data'</span>]).should.equal(<span class="hljs-literal">true</span>);
      assert.isNull(bst.left);
      assert.isNull(bst.right);
    });

    it(<span class="hljs-string">"Insert on the left if key is less than the root's"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'some data'</span>);
      bst.insert(<span class="hljs-number">7</span>, <span class="hljs-string">'some other data'</span>);

      bst.checkIsBST();
      assert.isNull(bst.right);
      bst.left.key.should.equal(<span class="hljs-number">7</span>);
      _.isEqual(bst.left.data, [<span class="hljs-string">'some other data'</span>]).should.equal(<span class="hljs-literal">true</span>);
      assert.isNull(bst.left.left);
      assert.isNull(bst.left.right);
    });

    it(<span class="hljs-string">"Insert on the right if key is greater than the root's"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'some data'</span>);
      bst.insert(<span class="hljs-number">14</span>, <span class="hljs-string">'some other data'</span>);

      bst.checkIsBST();
      assert.isNull(bst.left);
      bst.right.key.should.equal(<span class="hljs-number">14</span>);
      _.isEqual(bst.right.data, [<span class="hljs-string">'some other data'</span>]).should.equal(<span class="hljs-literal">true</span>);
      assert.isNull(bst.right.left);
      assert.isNull(bst.right.right);
    });

    it(<span class="hljs-string">"Recursive insertion on the left works"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'some data'</span>);
      bst.insert(<span class="hljs-number">7</span>, <span class="hljs-string">'some other data'</span>);
      bst.insert(<span class="hljs-number">1</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">9</span>, <span class="hljs-string">'world'</span>);

      bst.checkIsBST();
      assert.isNull(bst.right);
      bst.left.key.should.equal(<span class="hljs-number">7</span>);
      _.isEqual(bst.left.data, [<span class="hljs-string">'some other data'</span>]).should.equal(<span class="hljs-literal">true</span>);

      bst.left.left.key.should.equal(<span class="hljs-number">1</span>);
      _.isEqual(bst.left.left.data, [<span class="hljs-string">'hello'</span>]).should.equal(<span class="hljs-literal">true</span>);

      bst.left.right.key.should.equal(<span class="hljs-number">9</span>);
      _.isEqual(bst.left.right.data, [<span class="hljs-string">'world'</span>]).should.equal(<span class="hljs-literal">true</span>);
    });

    it(<span class="hljs-string">"Recursive insertion on the right works"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'some data'</span>);
      bst.insert(<span class="hljs-number">17</span>, <span class="hljs-string">'some other data'</span>);
      bst.insert(<span class="hljs-number">11</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">19</span>, <span class="hljs-string">'world'</span>);

      bst.checkIsBST();
      assert.isNull(bst.left);
      bst.right.key.should.equal(<span class="hljs-number">17</span>);
      _.isEqual(bst.right.data, [<span class="hljs-string">'some other data'</span>]).should.equal(<span class="hljs-literal">true</span>);

      bst.right.left.key.should.equal(<span class="hljs-number">11</span>);
      _.isEqual(bst.right.left.data, [<span class="hljs-string">'hello'</span>]).should.equal(<span class="hljs-literal">true</span>);

      bst.right.right.key.should.equal(<span class="hljs-number">19</span>);
      _.isEqual(bst.right.right.data, [<span class="hljs-string">'world'</span>]).should.equal(<span class="hljs-literal">true</span>);
    });

    it(<span class="hljs-string">'If uniqueness constraint not enforced, we can insert different data for same key'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'some data'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'world'</span>);

      bst.checkIsBST();
      bst.left.key.should.equal(<span class="hljs-number">3</span>);
      _.isEqual(bst.left.data, [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]).should.equal(<span class="hljs-literal">true</span>);

      bst.insert(<span class="hljs-number">12</span>, <span class="hljs-string">'a'</span>);
      bst.insert(<span class="hljs-number">12</span>, <span class="hljs-string">'b'</span>);

      bst.checkIsBST();
      bst.right.key.should.equal(<span class="hljs-number">12</span>);
      _.isEqual(bst.right.data, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).should.equal(<span class="hljs-literal">true</span>);
    });

    it(<span class="hljs-string">'If uniqueness constraint is enforced, we cannot insert different data for same key'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree({ unique: <span class="hljs-literal">true</span> });

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'some data'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'hello'</span>);
      <span class="hljs-keyword">try</span> {
        bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'world'</span>);
      } <span class="hljs-keyword">catch</span> (e) {
        e.errorType.should.equal(<span class="hljs-string">'uniqueViolated'</span>);
        e.key.should.equal(<span class="hljs-number">3</span>);
      }

      bst.checkIsBST();
      bst.left.key.should.equal(<span class="hljs-number">3</span>);
      _.isEqual(bst.left.data, [<span class="hljs-string">'hello'</span>]).should.equal(<span class="hljs-literal">true</span>);

      bst.insert(<span class="hljs-number">12</span>, <span class="hljs-string">'a'</span>);
      <span class="hljs-keyword">try</span> {
        bst.insert(<span class="hljs-number">12</span>, <span class="hljs-string">'world'</span>);
      } <span class="hljs-keyword">catch</span> (e) {
        e.errorType.should.equal(<span class="hljs-string">'uniqueViolated'</span>);
        e.key.should.equal(<span class="hljs-number">12</span>);
      }

      bst.checkIsBST();
      bst.right.key.should.equal(<span class="hljs-number">12</span>);
      _.isEqual(bst.right.data, [<span class="hljs-string">'a'</span>]).should.equal(<span class="hljs-literal">true</span>);
    });

    it(<span class="hljs-string">'Can insert 0 or the empty string'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">0</span>, <span class="hljs-string">'some data'</span>);

      bst.checkIsBST();
      bst.key.should.equal(<span class="hljs-number">0</span>);
      _.isEqual(bst.data, [<span class="hljs-string">'some data'</span>]).should.equal(<span class="hljs-literal">true</span>);
      assert.isNull(bst.left);
      assert.isNull(bst.right);

      bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-string">''</span>, <span class="hljs-string">'some other data'</span>);

      bst.checkIsBST();
      bst.key.should.equal(<span class="hljs-string">''</span>);
      _.isEqual(bst.data, [<span class="hljs-string">'some other data'</span>]).should.equal(<span class="hljs-literal">true</span>);
      assert.isNull(bst.left);
      assert.isNull(bst.right);
    });

    it(<span class="hljs-string">'Can insert a lot of keys and still get a BST (sanity check)'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree({ unique: <span class="hljs-literal">true</span> });

      customUtils.getRandomArray(<span class="hljs-number">100</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
        bst.insert(n, <span class="hljs-string">'some data'</span>);
      });

      bst.checkIsBST();
    });

    it(<span class="hljs-string">'All children get a pointer to their parent, the root doesnt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'root'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">15</span>, <span class="hljs-string">'no'</span>);

      bst.checkIsBST();

      assert.isNull(bst.parent);
      bst.left.parent.should.equal(bst);
      bst.right.parent.should.equal(bst);
    });

  });   <span class="hljs-comment">// ==== End of 'Insertion' ==== //</span>


  describe(<span class="hljs-string">'Search'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

    it(<span class="hljs-string">'Can find data in a BST'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree()
        , i;

      customUtils.getRandomArray(<span class="hljs-number">100</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
        bst.insert(n, <span class="hljs-string">'some data for '</span> + n);
      });

      bst.checkIsBST();

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i += <span class="hljs-number">1</span>) {
        _.isEqual(bst.search(i), [<span class="hljs-string">'some data for '</span> + i]).should.equal(<span class="hljs-literal">true</span>);
      }
    });

    it(<span class="hljs-string">'If no data can be found, return an empty array'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      customUtils.getRandomArray(<span class="hljs-number">100</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
        <span class="hljs-keyword">if</span> (n !== <span class="hljs-number">63</span>) {
          bst.insert(n, <span class="hljs-string">'some data for '</span> + n);
        }
      });

      bst.checkIsBST();

      bst.search(-<span class="hljs-number">2</span>).length.should.equal(<span class="hljs-number">0</span>);
      bst.search(<span class="hljs-number">100</span>).length.should.equal(<span class="hljs-number">0</span>);
      bst.search(<span class="hljs-number">101</span>).length.should.equal(<span class="hljs-number">0</span>);
      bst.search(<span class="hljs-number">63</span>).length.should.equal(<span class="hljs-number">0</span>);
    });

    it(<span class="hljs-string">'Can search for data between two bounds'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">18</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'data '</span> + k);
      });

      assert.deepEqual(bst.betweenBounds({ $gte: <span class="hljs-number">8</span>, $lte: <span class="hljs-number">15</span> }), [<span class="hljs-string">'data 8'</span>, <span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>, <span class="hljs-string">'data 15'</span>]);
      assert.deepEqual(bst.betweenBounds({ $gt: <span class="hljs-number">8</span>, $lt: <span class="hljs-number">15</span> }), [<span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>]);
    });

    it(<span class="hljs-string">'Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">18</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'data '</span> + k);
      });

      assert.deepEqual(bst.betweenBounds({ $gt:<span class="hljs-number">8</span>, $gte: <span class="hljs-number">8</span>, $lte: <span class="hljs-number">15</span> }), [<span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>, <span class="hljs-string">'data 15'</span>]);
      assert.deepEqual(bst.betweenBounds({ $gt:<span class="hljs-number">5</span>, $gte: <span class="hljs-number">8</span>, $lte: <span class="hljs-number">15</span> }), [<span class="hljs-string">'data 8'</span>, <span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>, <span class="hljs-string">'data 15'</span>]);
      assert.deepEqual(bst.betweenBounds({ $gt:<span class="hljs-number">8</span>, $gte: <span class="hljs-number">5</span>, $lte: <span class="hljs-number">15</span> }), [<span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>, <span class="hljs-string">'data 15'</span>]);

      assert.deepEqual(bst.betweenBounds({ $gte: <span class="hljs-number">8</span>, $lte: <span class="hljs-number">15</span>, $lt: <span class="hljs-number">15</span> }), [<span class="hljs-string">'data 8'</span>, <span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>]);
      assert.deepEqual(bst.betweenBounds({ $gte: <span class="hljs-number">8</span>, $lte: <span class="hljs-number">18</span>, $lt: <span class="hljs-number">15</span> }), [<span class="hljs-string">'data 8'</span>, <span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>]);
      assert.deepEqual(bst.betweenBounds({ $gte: <span class="hljs-number">8</span>, $lte: <span class="hljs-number">15</span>, $lt: <span class="hljs-number">18</span> }), [<span class="hljs-string">'data 8'</span>, <span class="hljs-string">'data 10'</span>, <span class="hljs-string">'data 13'</span>, <span class="hljs-string">'data 15'</span>]);
    });

    it(<span class="hljs-string">'Bounded search can work when one or both boundaries are missing'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">18</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'data '</span> + k);
      });

      assert.deepEqual(bst.betweenBounds({ $gte: <span class="hljs-number">11</span> }), [<span class="hljs-string">'data 13'</span>, <span class="hljs-string">'data 15'</span>, <span class="hljs-string">'data 18'</span>]);
      assert.deepEqual(bst.betweenBounds({ $lte: <span class="hljs-number">9</span> }), [<span class="hljs-string">'data 3'</span>, <span class="hljs-string">'data 5'</span>, <span class="hljs-string">'data 8'</span>]);
    });

  });   <span class="hljs-comment">/// ==== End of 'Search' ==== //</span>


  describe(<span class="hljs-string">'Deletion'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

    it(<span class="hljs-string">'Deletion does nothing on an empty tree'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree()
        , bstu = <span class="hljs-keyword">new</span> BinarySearchTree({ unique: <span class="hljs-literal">true</span> });

      bst.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);
      bstu.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);

      bst.delete(<span class="hljs-number">5</span>);
      bstu.delete(<span class="hljs-number">5</span>);

      bst.hasOwnProperty(<span class="hljs-string">'key'</span>).should.equal(<span class="hljs-literal">false</span>);
      bstu.hasOwnProperty(<span class="hljs-string">'key'</span>).should.equal(<span class="hljs-literal">false</span>);

      bst.data.length.should.equal(<span class="hljs-number">0</span>);
      bstu.data.length.should.equal(<span class="hljs-number">0</span>);

      bst.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);
      bstu.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);
    });

    it(<span class="hljs-string">'Deleting a non-existent key doesnt have any effect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">37</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'some '</span> + k);
      });

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkBst</span> <span class="hljs-params">()</span> </span>{
        [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">37</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
          _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
        });
      }

      checkBst();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);

      bst.delete(<span class="hljs-number">2</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">4</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">9</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">6</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">11</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">14</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">20</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">200</span>);
      checkBst(); bst.checkIsBST(); bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
    });

    it(<span class="hljs-string">'Able to delete the root if it is also a leaf'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'hello'</span>);
      bst.key.should.equal(<span class="hljs-number">10</span>);
      _.isEqual(bst.data, [<span class="hljs-string">'hello'</span>]).should.equal(<span class="hljs-literal">true</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">1</span>);

      bst.delete(<span class="hljs-number">10</span>);
      bst.hasOwnProperty(<span class="hljs-string">'key'</span>).should.equal(<span class="hljs-literal">false</span>);
      bst.data.length.should.equal(<span class="hljs-number">0</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);
    });

    it(<span class="hljs-string">'Able to delete leaf nodes that are non-root'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recreateBst</span> <span class="hljs-params">()</span> </span>{
        bst = <span class="hljs-keyword">new</span> BinarySearchTree();</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>With this insertion order the tree is well balanced
So we know the leaves are 3, 8, 12, 37</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">37</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
          bst.insert(k, <span class="hljs-string">'some '</span> + k);
        });

        bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkOnlyOneWasRemoved</span> <span class="hljs-params">(theRemoved)</span> </span>{
        [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">37</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
          <span class="hljs-keyword">if</span> (k === theRemoved) {
            bst.search(k).length.should.equal(<span class="hljs-number">0</span>);
          } <span class="hljs-keyword">else</span> {
            _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
          }
        });

        bst.getNumberOfKeys().should.equal(<span class="hljs-number">6</span>);
      }

      recreateBst();
      bst.delete(<span class="hljs-number">3</span>);
      bst.checkIsBST();
      checkOnlyOneWasRemoved(<span class="hljs-number">3</span>);
      assert.isNull(bst.left.left);

      recreateBst();
      bst.delete(<span class="hljs-number">8</span>);
      bst.checkIsBST();
      checkOnlyOneWasRemoved(<span class="hljs-number">8</span>);
      assert.isNull(bst.left.right);

      recreateBst();
      bst.delete(<span class="hljs-number">12</span>);
      bst.checkIsBST();
      checkOnlyOneWasRemoved(<span class="hljs-number">12</span>);
      assert.isNull(bst.right.left);

      recreateBst();
      bst.delete(<span class="hljs-number">37</span>);
      bst.checkIsBST();
      checkOnlyOneWasRemoved(<span class="hljs-number">37</span>);
      assert.isNull(bst.right.right);
    });

    it(<span class="hljs-string">'Able to delete the root if it has only one child'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Root has only one child, on the left</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      bst = <span class="hljs-keyword">new</span> BinarySearchTree();
      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'some '</span> + k);
      });
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);
      bst.delete(<span class="hljs-number">10</span>);
      bst.checkIsBST();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
      [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
      });
      bst.search(<span class="hljs-number">10</span>).length.should.equal(<span class="hljs-number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Root has only one child, on the right</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      bst = <span class="hljs-keyword">new</span> BinarySearchTree();
      [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'some '</span> + k);
      });
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);
      bst.delete(<span class="hljs-number">10</span>);
      bst.checkIsBST();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
      [<span class="hljs-number">15</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
      });
      bst.search(<span class="hljs-number">10</span>).length.should.equal(<span class="hljs-number">0</span>);
    });

    it(<span class="hljs-string">'Able to delete non root nodes that have only one child'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recreateBst</span> <span class="hljs-params">()</span> </span>{
        bst = <span class="hljs-keyword">new</span> BinarySearchTree();

        [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>, <span class="hljs-number">17</span>, <span class="hljs-number">25</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
          bst.insert(k, <span class="hljs-string">'some '</span> + k);
        });

        bst.getNumberOfKeys().should.equal(<span class="hljs-number">9</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkOnlyOneWasRemoved</span> <span class="hljs-params">(theRemoved)</span> </span>{
        [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>, <span class="hljs-number">17</span>, <span class="hljs-number">25</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
          <span class="hljs-keyword">if</span> (k === theRemoved) {
            bst.search(k).length.should.equal(<span class="hljs-number">0</span>);
          } <span class="hljs-keyword">else</span> {
            _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
          }
        });

        bst.getNumberOfKeys().should.equal(<span class="hljs-number">8</span>);
      }

      recreateBst();
      bst.delete(<span class="hljs-number">5</span>);
      bst.checkIsBST();
      checkOnlyOneWasRemoved(<span class="hljs-number">5</span>);

      recreateBst();
      bst.delete(<span class="hljs-number">15</span>);
      bst.checkIsBST();
      checkOnlyOneWasRemoved(<span class="hljs-number">15</span>);
    });

    it(<span class="hljs-string">'Can delete the root if it has 2 children'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst;

      bst = <span class="hljs-keyword">new</span> BinarySearchTree();
      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">37</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'some '</span> + k);
      });
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">7</span>);
      bst.delete(<span class="hljs-number">10</span>);
      bst.checkIsBST();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">6</span>);
      [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">37</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
      });
      bst.search(<span class="hljs-number">10</span>).length.should.equal(<span class="hljs-number">0</span>);
    });

    it(<span class="hljs-string">'Can delete a non-root node that has two children'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst;

      bst = <span class="hljs-keyword">new</span> BinarySearchTree();
      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">20</span>, <span class="hljs-number">19</span>, <span class="hljs-number">42</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'some '</span> + k);
      });
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">15</span>);
      bst.delete(<span class="hljs-number">5</span>);
      bst.checkIsBST();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">14</span>);
      [<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">20</span>, <span class="hljs-number">19</span>, <span class="hljs-number">42</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
      });
      bst.search(<span class="hljs-number">5</span>).length.should.equal(<span class="hljs-number">0</span>);

      bst = <span class="hljs-keyword">new</span> BinarySearchTree();
      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">20</span>, <span class="hljs-number">19</span>, <span class="hljs-number">42</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        bst.insert(k, <span class="hljs-string">'some '</span> + k);
      });
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">15</span>);
      bst.delete(<span class="hljs-number">15</span>);
      bst.checkIsBST();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">14</span>);
      [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">20</span>, <span class="hljs-number">19</span>, <span class="hljs-number">42</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(k)</span> </span>{
        _.isEqual(bst.search(k), [<span class="hljs-string">'some '</span> + k]).should.equal(<span class="hljs-literal">true</span>);
      });
      bst.search(<span class="hljs-number">15</span>).length.should.equal(<span class="hljs-number">0</span>);
    });

    it(<span class="hljs-string">'If no value is provided, it will delete the entire node even if there are multiple pieces of data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'world'</span>);
      bst.insert(<span class="hljs-number">8</span>, <span class="hljs-string">'yes'</span>);

      assert.deepEqual(bst.search(<span class="hljs-number">5</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);

      bst.delete(<span class="hljs-number">5</span>);
      bst.search(<span class="hljs-number">5</span>).length.should.equal(<span class="hljs-number">0</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
    });

    it(<span class="hljs-string">'Can remove only one value from an array'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'world'</span>);
      bst.insert(<span class="hljs-number">8</span>, <span class="hljs-string">'yes'</span>);

      assert.deepEqual(bst.search(<span class="hljs-number">5</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);

      bst.delete(<span class="hljs-number">5</span>, <span class="hljs-string">'hello'</span>);
      assert.deepEqual(bst.search(<span class="hljs-number">5</span>), [<span class="hljs-string">'world'</span>]);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);
    });

    it(<span class="hljs-string">'Removes nothing if value doesnt match'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'world'</span>);
      bst.insert(<span class="hljs-number">8</span>, <span class="hljs-string">'yes'</span>);

      assert.deepEqual(bst.search(<span class="hljs-number">5</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);

      bst.delete(<span class="hljs-number">5</span>, <span class="hljs-string">'nope'</span>);
      assert.deepEqual(bst.search(<span class="hljs-number">5</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);
    });

    it(<span class="hljs-string">'If value provided but node contains only one value, remove entire node'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'yes2'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'world'</span>);
      bst.insert(<span class="hljs-number">8</span>, <span class="hljs-string">'yes3'</span>);

      assert.deepEqual(bst.search(<span class="hljs-number">3</span>), [<span class="hljs-string">'yes2'</span>]);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);

      bst.delete(<span class="hljs-number">3</span>, <span class="hljs-string">'yes2'</span>);
      bst.search(<span class="hljs-number">3</span>).length.should.equal(<span class="hljs-number">0</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
    });

    it(<span class="hljs-string">'Can remove the root from a tree with height 2 when the root has two children (special case)'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'maybe'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'no'</span>);
      bst.insert(<span class="hljs-number">15</span>, <span class="hljs-string">'yes'</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);

      bst.delete(<span class="hljs-number">10</span>);
      bst.checkIsBST();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
      assert.deepEqual(bst.search(<span class="hljs-number">5</span>), [<span class="hljs-string">'no'</span>]);
      assert.deepEqual(bst.search(<span class="hljs-number">15</span>), [<span class="hljs-string">'yes'</span>]);
    });

    it(<span class="hljs-string">'Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'maybe'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'no'</span>);
      bst.insert(<span class="hljs-number">15</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">2</span>, <span class="hljs-string">'no'</span>);
      bst.insert(<span class="hljs-number">35</span>, <span class="hljs-string">'yes'</span>);
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">5</span>);

      bst.delete(<span class="hljs-number">10</span>);
      bst.checkIsBST();
      bst.getNumberOfKeys().should.equal(<span class="hljs-number">4</span>);
      assert.deepEqual(bst.search(<span class="hljs-number">5</span>), [<span class="hljs-string">'no'</span>]);
      assert.deepEqual(bst.search(<span class="hljs-number">15</span>), [<span class="hljs-string">'yes'</span>]);
    });

  });   <span class="hljs-comment">// ==== End of 'Deletion' ==== //</span>


  it(<span class="hljs-string">'Can use undefined as key and value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareKeys</span> <span class="hljs-params">(a, b)</span> </span>{
      <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">undefined</span> &amp;&amp; b === <span class="hljs-literal">undefined</span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
      <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">undefined</span>) { <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; }
      <span class="hljs-keyword">if</span> (b === <span class="hljs-literal">undefined</span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }

      <span class="hljs-keyword">if</span> (a &lt; b) { <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; }
      <span class="hljs-keyword">if</span> (a &gt; b) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
      <span class="hljs-keyword">if</span> (a === b) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
    }

    <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree({ compareKeys: compareKeys });

    bst.insert(<span class="hljs-number">2</span>, <span class="hljs-literal">undefined</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">1</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), []);

    bst.insert(<span class="hljs-literal">undefined</span>, <span class="hljs-string">'hello'</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), [<span class="hljs-string">'hello'</span>]);

    bst.insert(<span class="hljs-literal">undefined</span>, <span class="hljs-string">'world'</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);

    bst.insert(<span class="hljs-number">4</span>, <span class="hljs-literal">undefined</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);

    bst.delete(<span class="hljs-literal">undefined</span>, <span class="hljs-string">'hello'</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), [<span class="hljs-string">'world'</span>]);

    bst.delete(<span class="hljs-literal">undefined</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), []);

    bst.delete(<span class="hljs-number">2</span>, <span class="hljs-literal">undefined</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">1</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), []);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">undefined</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), []);

    bst.delete(<span class="hljs-number">4</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), []);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), []);
    assert.deepEqual(bst.search(<span class="hljs-literal">undefined</span>), []);
  });


  it(<span class="hljs-string">'Can use null as key and value'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareKeys</span> <span class="hljs-params">(a, b)</span> </span>{
      <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">null</span> &amp;&amp; b === <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
      <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; }
      <span class="hljs-keyword">if</span> (b === <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }

      <span class="hljs-keyword">if</span> (a &lt; b) { <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; }
      <span class="hljs-keyword">if</span> (a &gt; b) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
      <span class="hljs-keyword">if</span> (a === b) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
    }

    <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree({ compareKeys: compareKeys });

    bst.insert(<span class="hljs-number">2</span>, <span class="hljs-literal">null</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">1</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), []);

    bst.insert(<span class="hljs-literal">null</span>, <span class="hljs-string">'hello'</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), [<span class="hljs-string">'hello'</span>]);

    bst.insert(<span class="hljs-literal">null</span>, <span class="hljs-string">'world'</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);

    bst.insert(<span class="hljs-number">4</span>, <span class="hljs-literal">null</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]);

    bst.delete(<span class="hljs-literal">null</span>, <span class="hljs-string">'hello'</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">3</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), [<span class="hljs-string">'world'</span>]);

    bst.delete(<span class="hljs-literal">null</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">2</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), []);

    bst.delete(<span class="hljs-number">2</span>, <span class="hljs-literal">null</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">1</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), []);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), [<span class="hljs-literal">null</span>]);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), []);

    bst.delete(<span class="hljs-number">4</span>);
    bst.checkIsBST();
    bst.getNumberOfKeys().should.equal(<span class="hljs-number">0</span>);
    assert.deepEqual(bst.search(<span class="hljs-number">2</span>), []);
    assert.deepEqual(bst.search(<span class="hljs-number">4</span>), []);
    assert.deepEqual(bst.search(<span class="hljs-literal">null</span>), []);
  });


  describe(<span class="hljs-string">'Execute on every node (=tree traversal)'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

    it(<span class="hljs-string">'Can execute a function on every node'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree()
        , keys = []
        , executed = <span class="hljs-number">0</span>
        ;

      bst.insert(<span class="hljs-number">10</span>, <span class="hljs-string">'yes'</span>);
      bst.insert(<span class="hljs-number">5</span>, <span class="hljs-string">'hello'</span>);
      bst.insert(<span class="hljs-number">3</span>, <span class="hljs-string">'yes2'</span>);
      bst.insert(<span class="hljs-number">8</span>, <span class="hljs-string">'yes3'</span>);
      bst.insert(<span class="hljs-number">15</span>, <span class="hljs-string">'yes3'</span>);
      bst.insert(<span class="hljs-number">159</span>, <span class="hljs-string">'yes3'</span>);
      bst.insert(<span class="hljs-number">11</span>, <span class="hljs-string">'yes3'</span>);

      bst.executeOnEveryNode(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> </span>{
        keys.push(node.key);
        executed += <span class="hljs-number">1</span>;
      });

      assert.deepEqual(keys, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>, <span class="hljs-number">159</span>]);
      executed.should.equal(<span class="hljs-number">7</span>);
    });

  });   <span class="hljs-comment">// ==== End of 'Execute on every node' ==== //</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>This test performs several inserts and deletes at random, always checking the content
of the tree are as expected and the binary search tree constraint is respected
This test is important because it can catch bugs other tests can’t
By their nature, BSTs can be hard to test (many possible cases, bug at one operation whose
effect begins to be felt only after several operations etc.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  describe(<span class="hljs-string">'Randomized test (takes much longer than the rest of the test suite)'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree()
      , data = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Check a bst against a simple key =&gt; [data] object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkDataIsTheSame</span> <span class="hljs-params">(bst, data)</span> </span>{
      <span class="hljs-keyword">var</span> bstDataElems = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>bstDataElems is a simple array containing every piece of data in the tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      bst.executeOnEveryNode(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node)</span> </span>{
        <span class="hljs-keyword">var</span> i;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; node.data.length; i += <span class="hljs-number">1</span>) {
          bstDataElems.push(node.data[i]);
        }
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Number of key and number of pieces of data match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      bst.getNumberOfKeys().should.equal(<span class="hljs-built_in">Object</span>.keys(data).length);
      _.reduce(_.map(data, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(d)</span> </span>{ <span class="hljs-keyword">return</span> d.length; }), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(memo, n)</span> </span>{ <span class="hljs-keyword">return</span> memo + n; }, <span class="hljs-number">0</span>).should.equal(bstDataElems.length);</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Compare data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key)</span> </span>{
        checkDataEquality(bst.search(key), data[key]);
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Check two pieces of data coming from the bst and data are the same</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkDataEquality</span> <span class="hljs-params">(fromBst, fromData)</span> </span>{
      <span class="hljs-keyword">if</span> (fromBst.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (fromData) { fromData.length.should.equal(<span class="hljs-number">0</span>); }
      }

      assert.deepEqual(fromBst, fromData);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Tests the tree structure (deletions concern the whole tree, deletion of some data in a node is well tested above)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    it(<span class="hljs-string">'Inserting and deleting entire nodes'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>You can skew to be more insertive or deletive, to test all cases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">launchRandomTest</span> <span class="hljs-params">(nTests, proba)</span> </span>{
        <span class="hljs-keyword">var</span> i, key, dataPiece, possibleKeys;

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nTests; i += <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &gt; proba) {   <span class="hljs-comment">// Deletion</span>
            possibleKeys = <span class="hljs-built_in">Object</span>.keys(data);

            <span class="hljs-keyword">if</span> (possibleKeys.length &gt; <span class="hljs-number">0</span>) {
              key = possibleKeys[<span class="hljs-built_in">Math</span>.floor(possibleKeys.length * <span class="hljs-built_in">Math</span>.random()).toString()];
            } <span class="hljs-keyword">else</span> {
              key = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">70</span> * <span class="hljs-built_in">Math</span>.random()).toString();
            }

            <span class="hljs-keyword">delete</span> data[key];
            bst.delete(key);
          } <span class="hljs-keyword">else</span> {   <span class="hljs-comment">// Insertion</span>
            key = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">70</span> * <span class="hljs-built_in">Math</span>.random()).toString();
            dataPiece = <span class="hljs-built_in">Math</span>.random().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
            bst.insert(key, dataPiece);
            <span class="hljs-keyword">if</span> (data[key]) {
              data[key].push(dataPiece);
            } <span class="hljs-keyword">else</span> {
              data[key] = [dataPiece];
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Check the bst constraint are still met and the data is correct</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          bst.checkIsBST();
          checkDataIsTheSame(bst, data);
        }
      }

      launchRandomTest(<span class="hljs-number">1000</span>, <span class="hljs-number">0.65</span>);
      launchRandomTest(<span class="hljs-number">2000</span>, <span class="hljs-number">0.35</span>);
    });

  });   <span class="hljs-comment">// ==== End of 'Randomized test' ==== //</span>



});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
